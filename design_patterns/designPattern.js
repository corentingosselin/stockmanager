// voici la liste des principaux design patterns:

/*
    1. Factory
    2. Decorator
    3. Strategy
    4. Adapter
    5. Facade
    6. Builder
*/

// Voici plusieurs contextes, choisissez le design pattern le plus adapté à chaque contexte:

// A.  Un système de messagerie qui est capable de prendre whatsapp, sms, email, facebook messenger, etc...
// Ce système est capable d'envoyer des messages à partir de n'importe quelle plateforme.
// on doit pouvoir combiner plusieurs plateformes pour envoyer un message 


// B. On a un cinema avec une salle de projection, un bar, un restaurant, un guichet, un parking, etc...
// On veut pouvoir gérer le cinema facilement avec des fonctions comme:
// - acheter un ticket
// - commander un repas
// - commander une boisson
// - trouver une place de parking
// - etc...

// C. On a un système de craft dans un jeu vidéo, permettant de fabriquer une épée, cette arme peut être améliorée
// en ajoutan un enchantement, ajouter de la force, de la vitesse, une couleur spécifique, un nom personnalisé, ect...

// D. Notre application utilise une API pour intéragir avec des intelligences artificielles,
// l'application est un chatbot qui permet de répondre aux questions des utilisateurs.
// Cette API utilise actuellement ChatGpt, mais on veut pouvoir facilement changer d'API 
// sans avoir à changer le code de l'application.
// On veut pouvoir utiliser ChatGpt, DialogFlow, Rasa, etc..

// E. L'entreprise Ford peut produire des voitures, des camions, des motos
// en fonction de la demande des clients, on veut pouvoir fabriquer des véhicules
// l'objectif est de pouvoir produire des véhicules de manière flexible
// par exemple buildVehicle("moto"), buildVehicle("camion"), ect

// F. Notre application utilise une class pour gérer les paiements des clients
// processPayment(amount)
// On vient de signer un contrat avec paypal, on veut pouvoir utiliser paypal

// trouver le design pattern le plus adapté à chaque contexte:




